<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jintin&#39;s Note</title>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://Jintin.github.io/blog/"/>
  <updated>2016-04-26T14:19:17.000Z</updated>
  <id>https://Jintin.github.io/blog/</id>
  
  <author>
    <name>Jintin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>人機大戰</title>
    <link href="https://Jintin.github.io/blog/2016/03/15/alphago/"/>
    <id>https://Jintin.github.io/blog/2016/03/15/alphago/</id>
    <published>2016-03-15T12:50:42.000Z</published>
    <updated>2016-04-26T14:19:17.000Z</updated>
    
    <content type="html">&lt;p&gt;AlphaGo 跟李世石的五番棋最終以4:1結束了，讓人讚嘆演算法的力量。&lt;/p&gt;&lt;h2 id=&quot;AlphaGo-原理&quot;&gt;&lt;a href=&quot;#AlphaGo-原理&quot; class=&quot;headerlink&quot; title=&quot;AlphaGo 原理&quot;&gt;&lt;/a&gt;AlphaGo 原理&lt;/h2&gt;&lt;p&gt;圍棋本身沒有太多規則，就是一連串的黑白輪流下子，困難的是對每一次落子有太多選擇，而棋局又有太多個回合，所以讓棋局的變化太多，要參透這門技術幾乎是不可能。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;既然這麼麻煩那我們要怎麼讓電腦下圍棋呢，可以從現實生活尋找靈感，人類社會做決策有二種方式，一種是由該領域專家決定，另一種是多數表決。&lt;/p&gt;&lt;p&gt;教電腦也有這二種方式，一是把高手下棋的思維轉成電腦的邏輯寫成程式，電腦依據程式的規則來決定怎麼下，缺點是寫出的程式策略決定了棋力的高低，而複雜的事物就伴隨著複雜的規則。&lt;/p&gt;&lt;p&gt;另一種方式是讓電腦透過大量的資料自己歸納出如何下棋，人的思考有幾種特性，人在做一件不懂的事的時候會依據完成的結果來回饋自己，如果正確的話下次就會有更高的機率做一樣的決策，而失敗的決策就比較不會再度發生，不斷的循環就會減少犯錯的可能。我們可以把棋局分成很多層簡單的小策略，透過一連串的策略選擇讓電腦學習怎樣是對的怎樣是錯的。只要有夠多的資料電腦就可以慢慢學會如何做這些決策，也就學會了如何下圍棋。&lt;/p&gt;&lt;p&gt;AlphaGo 就是依據大量的資料來學習的，有以下三個模組組成：&lt;/p&gt;&lt;h3 id=&quot;1-SL-Policy-Network&quot;&gt;&lt;a href=&quot;#1-SL-Policy-Network&quot; class=&quot;headerlink&quot; title=&quot;1. SL Policy Network&quot;&gt;&lt;/a&gt;1. SL Policy Network&lt;/h3&gt;&lt;p&gt;用KGS的3000萬盤棋譜作為深度學習的資料，學習人類在棋局中如何走下一步，在模擬棋局的時候，可以有效的減少搜尋的廣度，不需考慮不必要下子的地方。&lt;/p&gt;&lt;h3 id=&quot;2-RL-Policy-Network&quot;&gt;&lt;a href=&quot;#2-RL-Policy-Network&quot; class=&quot;headerlink&quot; title=&quot;2. RL Policy Network&quot;&gt;&lt;/a&gt;2. RL Policy Network&lt;/h3&gt;&lt;p&gt;以 SL 為基礎加強，自己跟自己對局1億次，藉由更多的資料不斷進行參數調整優化預測更好的下一步。&lt;/p&gt;&lt;h3 id=&quot;3-Value-Network&quot;&gt;&lt;a href=&quot;#3-Value-Network&quot; class=&quot;headerlink&quot; title=&quot;3. Value Network&quot;&gt;&lt;/a&gt;3. Value Network&lt;/h3&gt;&lt;p&gt;給定任何盤面，分析黑白雙方的勝率，在模擬棋局的時候，可以有效減少搜尋的深度，當某點變化勝率太低就不需考慮以這點進行的變化。&lt;/p&gt;&lt;p&gt;綜合三個模組，就可以得到一個很像人下圍棋的電腦，知道要該下哪裡、也會算變化分析勝率，當勝率太低還會投子啊。&lt;/p&gt;&lt;h2 id=&quot;人腦-vs-電腦&quot;&gt;&lt;a href=&quot;#人腦-vs-電腦&quot; class=&quot;headerlink&quot; title=&quot;人腦 vs 電腦&quot;&gt;&lt;/a&gt;人腦 vs 電腦&lt;/h2&gt;&lt;p&gt;雖然說電腦透過深度學習最後還是打敗人類，但二者間還是有本質上的不同。&lt;/p&gt;&lt;p&gt;人類在下棋的時候，會有脈絡思路，可以感覺出對方是好戰或是保守，會感到壓力、疲勞、失誤，計算能力也有限。這都是人的缺點，但人類強的是思考、學習的能力，人類不需要看幾千萬盤棋才懂圍棋，這點可說是完勝電腦。&lt;/p&gt;&lt;p&gt;而電腦是用資料在下圍棋，當他決定下 A 點的時候只因為 A 點的勝率比其他點高，但並沒有其他原因。而且，雖然說 AlphaGo 是一種人工智慧，但本質上只是大數據的統計分析，跟一般網站推薦系統也沒有太多不一樣，離真正的人工智慧還很遙遠。&lt;/p&gt;&lt;p&gt;圍棋比賽除了作為一門競技，也是一門藝術。進退之間追求平衡，這部分恐怕只有人腦能懂了。最後，李世石的敗戰感言也很感人啊，這大概是人跟電腦最大的不同吧。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;雖然AlphaGo打敗了我一個李世石，但並不能說，就是打敗了整個人類。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;未來&quot;&gt;&lt;a href=&quot;#未來&quot; class=&quot;headerlink&quot; title=&quot;未來&quot;&gt;&lt;/a&gt;未來&lt;/h2&gt;&lt;p&gt;就算這次李世石並沒有被打敗，但理論上只要給電腦更多資料，總有一天還是可以贏人類的，這一天總會到來、快或慢而已。那接下來呢，圍棋會因此滅亡嗎，還是會開拓一片新的領域呢？相信藉由電腦的輔助人類可以看到圍棋更多的可能性，而電腦也需要更多人類下的棋譜才能進步。&lt;/p&gt;&lt;p&gt;而作為一個通用的人工智慧系統，圍棋上的應用應該不是終點，各行各業都有機會引入，讀大學的時候很常聽到的一句話是”十年後80%工作會消失，而十年後需要的工作現在還沒出現。”，變革的時代，代表的是挑戰、也是機會，如果可以很平順的轉換到新科技的世界，人類可以把更多的時間拿去思考、解決更重要的問題。&lt;/p&gt;&lt;p&gt;最後，如果哪天電腦開竅了會寫程式，會有工程師想跟他比寫程式嗎？&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;AlphaGo 跟李世石的五番棋最終以4:1結束了，讓人讚嘆演算法的力量。&lt;/p&gt;&lt;h2 id=&quot;AlphaGo-原理&quot;&gt;&lt;a href=&quot;#AlphaGo-原理&quot; class=&quot;headerlink&quot; title=&quot;AlphaGo 原理&quot;&gt;&lt;/a&gt;AlphaGo 原理&lt;/h2&gt;&lt;p&gt;圍棋本身沒有太多規則，就是一連串的黑白輪流下子，困難的是對每一次落子有太多選擇，而棋局又有太多個回合，所以讓棋局的變化太多，要參透這門技術幾乎是不可能。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>每月一語</title>
    <link href="https://Jintin.github.io/blog/2016/02/28/monthly-github/"/>
    <id>https://Jintin.github.io/blog/2016/02/28/monthly-github/</id>
    <published>2016-02-28T12:22:10.000Z</published>
    <updated>2016-04-26T14:21:09.000Z</updated>
    
    <content type="html">&lt;p&gt;當工程師好幾年了，但一直都只專注寫 Java，雖然對 Java 沒什麼特別不滿意的地方，但偶而也想多試試其它語言來增加自己的視野，於是大概在半年前開始給自己一個挑戰，每個月用一個不熟的語言寫個小工具分享到 github 上，很快地累積了好幾個小專案，分享自己的心得也順便介紹這些工具給大家，希望對大家有所幫助。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;jgit-Ruby&quot;&gt;&lt;a href=&quot;#jgit-Ruby&quot; class=&quot;headerlink&quot; title=&quot;jgit (Ruby)&quot;&gt;&lt;/a&gt;jgit (Ruby)&lt;/h2&gt;&lt;p&gt;git 是個很高效好用的版本控制工具，但如果同時有多個專案使用上有點不方便。jgit 就是想要解決這個情境，對 git 做擴展，解決在任意目錄下查詢任意一個或多個專案的 git 狀態，簡單說就是把 git command 分配到很多個目錄下執行。&lt;br&gt;比如說 &lt;code&gt;jgit status&lt;/code&gt; 可以取得目前群組的所有專案之 &lt;code&gt;git status&lt;/code&gt; 的結果，如果同時要開發或維護多個專案的時候很方便。&lt;/p&gt;&lt;p&gt;範例如下:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ jgit ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A: /Users/Jintin/Downloads/sample/sampleA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B: /Users/Jintin/Desktop/sample/sampleB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ jgit status&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - Task:A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;On branch master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nothing to commit, working directory clean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - Task:B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;On branch master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Changes not staged &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; commit:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (use &lt;span class=&quot;string&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to update what will be committed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (use &lt;span class=&quot;string&quot;&gt;&quot;git checkout -- &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to discard changes &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; working directory)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	modified:   newFile.json&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;no changes added to commit (use &lt;span class=&quot;string&quot;&gt;&quot;git add&quot;&lt;/span&gt; and/or &lt;span class=&quot;string&quot;&gt;&quot;git commit -a&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;&lt;p&gt;心得: 寫 ruby 一開始的時候蠻不習慣的，少了型別、不用 compile、語法也很不習慣。但慢慢覺得動態語言在小型專案下真的可以很方便解決很多問題，&lt;code&gt;gem&lt;/code&gt; 的設計很棒，不用 compile 習慣後開發速度也提升不少。&lt;/p&gt;&lt;p&gt;更多資訊可以參考 &lt;a href=&quot;https://github.com/Jintin/jgit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Jintin/jgit&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;transai-JavaScript&quot;&gt;&lt;a href=&quot;#transai-JavaScript&quot; class=&quot;headerlink&quot; title=&quot;transai (JavaScript)&quot;&gt;&lt;/a&gt;transai (JavaScript)&lt;/h2&gt;&lt;p&gt;transai 是處理 Android, iOS 多國語言的工具，可以在 Terminal 把這二個平台的語言檔解析出來合併為 csv 格式，等翻譯完了之後再轉回各自的資料夾中。&lt;/p&gt;&lt;p&gt;範例如下:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ transai load &lt;span class=&quot;_&quot;&gt;-a&lt;/span&gt; ~/android -i ~/ios --from en --to de -c ~/strings.csv&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ transai save &lt;span class=&quot;_&quot;&gt;-a&lt;/span&gt; ~/android -i ~/ios --from en --to de -c ~/strings.csv&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;&lt;p&gt;心得: JavaScript 跟 Ruby 一樣是動態但語法平易近人多了，而且 &lt;code&gt;npm&lt;/code&gt; 、 &lt;code&gt;node&lt;/code&gt; 的設計又更完善方便，是很好入門的一款語言，在各領域也都有很好的發揮機會，雖然不想承認但的確是最有機會統一程式語言的語言。&lt;/p&gt;&lt;p&gt;更多資訊可以參考 &lt;a href=&quot;https://github.com/Jintin/transai&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Jintin/transai&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;andle-Python&quot;&gt;&lt;a href=&quot;#andle-Python&quot; class=&quot;headerlink&quot; title=&quot;andle (Python)&quot;&gt;&lt;/a&gt;andle (Python)&lt;/h2&gt;&lt;p&gt;Android Studio 問世之後，大家一定很喜歡可以把 dependency 設定在 build.gradle 的特性，但相對的這個檔案的管理就變成一門學問了，你知道哪些 library 有更新的版本嗎？就算知道如果你有十個專案你要一個一個改嗎？&lt;br&gt;andle 就是幫你解決 dependency version的工具，可以直接在 Terminal 更新所有 library 為最新版本，如果你比較嚴謹也可以加上 &lt;code&gt;-d&lt;/code&gt; 只會列出新版版號不會修改。&lt;/p&gt;&lt;p&gt;範例如下:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ andle update &lt;span class=&quot;_&quot;&gt;-d&lt;/span&gt; -g -r&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;check ./build.gradle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;com.android.tools.build:gradle: 2.0.0-beta4 -&amp;gt; 2.0.0-beta6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;check ./A/build.gradle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;com.android.support:cardview-v7: 23.1.1 -&amp;gt; 23.2.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;check ./B/build.gradle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ok&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;check ./C/build.gradle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;com.android.support:support-v4: 23.1.1 -&amp;gt; 23.2.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;com.android.support:design: 23.1.1 -&amp;gt; 23.2.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;check ./gradle/wrapper/gradle-wrapper.properties&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ok&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;&lt;p&gt;心得: 又是一門動態語言，Terminal 幾乎都是動態語言的天下，語法上最大不習慣就是用縮排取代括弧，其他結構上跟Ruby有點類似，有點痛苦是 Python2.X 跟 Python3.X 有大改版，所以要二種都測試過比較保險，這種新版本一直出來，舊的版本又不能放棄的感覺跟 Android 實在是太契合了。&lt;/p&gt;&lt;p&gt;更多資訊可以參考 &lt;a href=&quot;https://github.com/Jintin/andle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Jintin/andle&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;Swimat-Objective-C&quot;&gt;&lt;a href=&quot;#Swimat-Objective-C&quot; class=&quot;headerlink&quot; title=&quot;Swimat (Objective-C)&quot;&gt;&lt;/a&gt;Swimat (Objective-C)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Jintin/Swimat/master/README/preview.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;Swift 是我除了 Java 以外很喜歡的一個語言，也是我接觸 iOS 開發的第一個語言。但 Xcode 對它的支援其實還蠻不足的，除了很慢連個基本的自動排版都沒有。&lt;br&gt;Swimat 就是一個簡單的 Swift 排版工具，可以安裝在 Xcode 裡，支援 Tab 或 Space 縮排、可以存檔自動排版。&lt;/p&gt;&lt;p&gt;心得: 原本排版 Swift 的程式，應該要用 Swift 寫，但因為要給自己挑戰選了不熟的 Objective-C，雖然沒什麼問題但寫起來真的很贅，無法支援 command line 非常可惜，要轉換回 Swift 也是一個大工程。&lt;/p&gt;&lt;p&gt;更多資訊可以參考 &lt;a href=&quot;https://github.com/Jintin/Swimat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Jintin/Swimat&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;DroidLane-Groovy&quot;&gt;&lt;a href=&quot;#DroidLane-Groovy&quot; class=&quot;headerlink&quot; title=&quot;DroidLane (Groovy)&quot;&gt;&lt;/a&gt;DroidLane (Groovy)&lt;/h2&gt;&lt;p&gt;寫完了 Xcode 的 plugin 後，就開始想是不是也可以幫 Android 這邊也寫一個。因為自己寫太多小 app，上架其實很麻煩所以就決定寫個自動上傳的工具。安裝後就不用打開瀏覽器可以在 Android Studio 裡直接上傳 apk。&lt;/p&gt;&lt;p&gt;心得: Groovy 其實就是 Java 的加強版，帶來一些好處也帶來一些缺點，我覺得最大缺點就是速度慢還要多包一些 Groovy 的 library。&lt;/p&gt;&lt;p&gt;更多資訊可以參考 &lt;a href=&quot;https://github.com/Jintin/DroidLane&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Jintin/DroidLane&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;aliasme-Shell&quot;&gt;&lt;a href=&quot;#aliasme-Shell&quot; class=&quot;headerlink&quot; title=&quot;aliasme (Shell)&quot;&gt;&lt;/a&gt;aliasme (Shell)&lt;/h2&gt;&lt;p&gt;身為工程師就是要用 command line 啊，但其實大家都不喜歡打字，切換目錄的時候如果太遠其實很不方便，aliasme 就是要解決這樣的需求，讓大家可以很方便的切換目錄。&lt;/p&gt;&lt;p&gt;範例如下:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ al add A ~/dirA/subA/A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ al add B ~/dirB/subB/B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ al A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;pwd&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/Users/Jintin/dirA/subA/A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ al B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;pwd&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/Users/Jintin/dirB/subB/B&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;&lt;p&gt;心得: 跟寫 Objective-C 一樣會感覺到時代的眼淚，如果可以用高階語言寫的就盡量用高階語言寫吧…&lt;/p&gt;&lt;p&gt;更多資訊可以參考 &lt;a href=&quot;https://github.com/Jintin/aliasme&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Jintin/aliasme&lt;/a&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;當工程師好幾年了，但一直都只專注寫 Java，雖然對 Java 沒什麼特別不滿意的地方，但偶而也想多試試其它語言來增加自己的視野，於是大概在半年前開始給自己一個挑戰，每個月用一個不熟的語言寫個小工具分享到 github 上，很快地累積了好幾個小專案，分享自己的心得也順便介紹這些工具給大家，希望對大家有所幫助。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
